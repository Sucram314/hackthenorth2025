<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lane Control ‚Äî MediaPipe Hand Posture</title>
  <style>
    :root { --bg:#0b1020; --fg:#e8eef7; --accent:#5ad; --muted:#a8b3c7; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg); background: radial-gradient(1200px 600px at 20% -10%, #1a2340 0%, #0b1020 50%, #060914 100%);
      min-height: 100dvh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(960px, 95vw);
      background: #101933cc; backdrop-filter: blur(6px);
      border: 1px solid #1e2a4d; border-radius: 18px; box-shadow: 0 15px 60px rgba(0,0,0,.35);
      padding: 18px 18px 12px; position: relative;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 3fr 2fr; } }
    h1 {
      margin: 2px 0 8px; font-weight: 700; letter-spacing: .2px;
      font-size: clamp(18px, 2.3vw, 26px);
      display:flex; align-items:center; gap:10px;
    }
    .badge { font-size: 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button {
      appearance: none; border: 1px solid #355; background: #0e1a33; color: var(--fg);
      padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: linear-gradient(180deg, #2b6cff, #1d54c9); border-color: #1d54c9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill {
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3c69;
      border-radius: 999px; color: var(--muted); font-size: 12px;
    }
    .stage {
      position: relative; width: 100%; aspect-ratio: 16 / 9;
      background: #060a18; border:1px solid #1b294f; border-radius:14px; overflow:hidden;
      display: flex; justify-content: center; align-items: center;
    }
    /* Only the video will be truly hidden if we draw on overlay */
    video { transform: scaleX(-1); position:absolute; top:0; left:0; width:100%; height:100%; object-fit: cover; }
    /* The overlay canvas will now be our main display */
    #overlay {
      position: absolute; inset: 0; width:100%; height:100%;
      pointer-events: none; /* Allow interaction with elements behind if any */
      transform: scaleX(-1); /* Mirror the canvas content to match video selfie view */
    }
    /* We no longer need a separate gameCanvas */
    #gameCanvas {
      display: none; /* Hide the gameCanvas as we're drawing on overlay */
    }
    .watermark {
      position:absolute; top:8px; right:10px; font-size:12px; color:#cfe3ff; opacity:.8;
      background:#0b1430aa; padding:6px 8px; border-radius:10px; border:1px solid #1e2a4d;
      z-index: 10; /* Ensure watermark is on top */
      transform: scaleX(-1); /* Un-mirror watermark text */
    }
    .log {
      padding: 10px 12px; border:1px dashed #28407a; border-radius:12px; color: #c9d7ee; background:#0d162e;
      min-height: 64px; white-space:pre-wrap;
    }
    a { color:#9bd; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#7f8; box-shadow:0 0 0 3px #122; }
  </style>
</head>
<body>
  <div class="card">
    <h1>‚úã Lane Control <span class="badge">‚Äî MediaPipe Hand Posture</span></h1>
    <div class="toolbar">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" disabled>Stop camera</button>
      <span class="pill"><span class="dot" id="dot"></span><span id="status">idle</span></span>
      <span class="pill" title="frames per second">FPS: <strong id="fps">0</strong></span>
      <span class="pill">Hands: <strong id="handsCount">0</strong></span>
      <span class="pill">Brushing: <strong id="brushingValue">0.00</strong></span>
      <span class="pill">Score: <strong id="score">0</strong>/<strong id="totalObstacles">0</strong></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="stage">
        <!-- The video element will now be the background source for the canvas -->
        <video id="video" playsinline muted></video>
        <!-- The overlay canvas will now draw everything: video, landmarks, and game -->
        <canvas id="overlay"></canvas>
        <!-- The dedicated gameCanvas is no longer needed -->
        <canvas id="gameCanvas" width="640" height="360" style="display:none;"></canvas>
        <div class="watermark">Hand landmarks + game overlay</div>
      </div>
      <div class="log" id="log">Click ‚ÄúStart camera‚Äù, allow permission, then hold your hand up üñêÔ∏è.
        Tilt your hand up for the top lane.
        Tilt your hand down for the bottom lane.
        Hold it flat for the middle lane.
        Brush your hand back and forth horizontally to make obstacles move faster!
      </div>
    </div>

    <footer>
      Tip: This runs fully in your browser. Use HTTPS or localhost for camera access. Model provided by Google‚Äôs MediaPipe Hand Landmarker.
    </footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      dot: document.getElementById('dot'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      handsCount: document.getElementById('handsCount'),
      brushingValue: document.getElementById('brushingValue'),
      score: document.getElementById('score'),
      totalObstacles: document.getElementById('totalObstacles'), // New UI element
      log: document.getElementById('log'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
    };

    let stream;
    let detector;
    let rafId = 0;
    let lastTime = 0, frames = 0, lastFpsUpdate = 0;

    const mainCtx = ui.overlay.getContext('2d');
    const drawer = new DrawingUtils(mainCtx);

    let overlayWidth = 0;
    let overlayHeight = 0;

    let LANE_HEIGHT;
    const PLAYER_SIZE = 40;
    let objectY;
    let targetY;
    let objectX;

    // Brushing detection variables
    const HISTORY_SIZE = 10;
    let handXPositions = [];
    let brushingValue = 0;
    const BRUSHING_DECAY = 0.9;
    const BRUSHING_IMPACT_FACTOR = 3; // How much brushing affects obstacle speed
    let smoothedBrushingImpact = 0; // New variable for smoothed impact
    const SMOOTHING_ALPHA = 0.1; // Smoothing factor (0 to 1, lower = more smooth)
    
    // Depth-based scaling variables
    const REFERENCE_DEPTH_Z = -0.1; // A typical Z-value for a hand at a "normal" distance (experiment with this)
    const DEPTH_SCALING_FACTOR = 1; // How strongly distance affects the scale (adjust as needed)

    // Game state variables
    let score = 0;
    let gameOver = false;
    let gameWon = false; // New game state variable
    let currentLaneState = "front"; // To keep track of the current hand posture state

    // Level definition and state
    const NUMBER_OF_OBSTACLES = 10; // Fixed number of obstacles for the level
    const OBSTACLE_SPACING_DISTANCE = 500; // Distance between obstacles (in pixels)
    let level = {
      obstacles: [],
      baseObstacleSpeed: 2, // Base speed for obstacles
      obstacleSize: 100, // Default obstacle size
      lanes: [0, 1, 2] // Lane indices
    };

    function setStatus(text){ ui.status.textContent = text; }
    function setLive(on){
      ui.dot.style.background = on ? '#7f8' : '#f88';
      setStatus(on ? 'live' : 'idle');
    }

    async function initDetector(){
      setStatus('loading model‚Ä¶');
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      detector = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    async function startCamera(){
      if (!detector) await initDetector();
      ui.startBtn.disabled = true;
      ui.stopBtn.disabled = false;
      setLive(true);
      gameOver = false;
      gameWon = false; // Reset game won state
      score = 0;
      ui.score.textContent = score;

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 960 }, height: { ideal: 540 } },
        audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();

      overlayWidth = ui.video.videoWidth;
      overlayHeight = ui.video.videoHeight;
      ui.overlay.width = overlayWidth;
      ui.overlay.height = overlayHeight;

      LANE_HEIGHT = overlayHeight / 3;
      objectY = LANE_HEIGHT * 1.5;
      targetY = objectY;
      objectX = overlayWidth / 4;

      handXPositions = [];
      brushingValue = 0;
      smoothedBrushingImpact = 0; // Initialize smoothed value
      currentLaneState = "front"; // Reset state on camera start

      // Initialize obstacles based on number and spacing
      level.obstacles = [];
      ui.totalObstacles.textContent = NUMBER_OF_OBSTACLES;
      for (let i = 0; i < NUMBER_OF_OBSTACLES; i++) {
        const randomLane = level.lanes[Math.floor(Math.random() * level.lanes.length)];
        level.obstacles.push({
          lane: randomLane,
          x: overlayWidth + (i * OBSTACLE_SPACING_DISTANCE) + level.obstacleSize, // Space them out initially
          speed: level.baseObstacleSpeed,
          size: level.obstacleSize,
          passed: false
        });
      }

      lastTime = -1; frames = 0; lastFpsUpdate = performance.now();
      loop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      mainCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
      ui.video.srcObject = null;
      ui.startBtn.disabled = false;
      ui.stopBtn.disabled = true;
      setLive(false);
      ui.handsCount.textContent = "0";
      ui.fps.textContent = "0";
      ui.brushingValue.textContent = "0.00";
      gameOver = true;
    }

    function estimateHandRotation(landmarks) {
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      const pinkyMcp = landmarks[17];

      const vecUpX = middleMcp.x - wrist.x;
      const vecUpY = middleMcp.y - wrist.y;
      const vecUpZ = middleMcp.z - wrist.z;

      const magUp = Math.sqrt(vecUpX*vecUpX + vecUpY*vecUpY + vecUpZ*vecUpZ);
      const normUpY = vecUpY / magUp;

      const pitch = Math.asin(normUpY) * (180 / Math.PI);

      const vecSideX = pinkyMcp.x - wrist.x;
      const vecSideY = pinkyMcp.y - wrist.y;
      const roll = Math.atan2(vecSideY, vecSideX) * (180 / Math.PI);

      const yaw = Math.atan2(vecUpX, -vecUpZ) * (180 / Math.PI);

      return {
        yaw: parseFloat(yaw.toFixed(2)),
        pitch: parseFloat(pitch.toFixed(2)),
        roll: parseFloat(roll.toFixed(2)),
      };
    }

    function getLaneFromPitch(pitch) {
        // Define base thresholds
        const BASE_UP_THRESHOLD = -60;
        const BASE_DOWN_THRESHOLD = 30;

        // Define hysteresis bias
        const HYSTERESIS_BIAS = 10; // degrees

        let upThreshold = BASE_UP_THRESHOLD;
        let downThreshold = BASE_DOWN_THRESHOLD;

        // Apply bias based on current state
        if (currentLaneState === "up") {
            // To go from "up" to "front", pitch must be greater than BASE_UP_THRESHOLD + BIAS
            upThreshold = BASE_UP_THRESHOLD + HYSTERESIS_BIAS;
        } else if (currentLaneState === "down") {
            // To go from "down" to "front", pitch must be less than BASE_DOWN_THRESHOLD - BIAS
            downThreshold = BASE_DOWN_THRESHOLD - HYSTERESIS_BIAS;
        } else if (currentLaneState === "front") {
            // To go from "front" to "up", pitch must be less than BASE_UP_THRESHOLD - BIAS
            // To go from "front" to "down", pitch must be greater than BASE_DOWN_THRESHOLD + BIAS
            upThreshold = BASE_UP_THRESHOLD - HYSTERESIS_BIAS;
            downThreshold = BASE_DOWN_THRESHOLD + HYSTERESIS_BIAS;
        }

        let newState;
        if (pitch < upThreshold) {
            newState = "down"; // Hand tilted upwards, means 'down' in selfie view
        } else if (pitch > downThreshold) {
            newState = "up"; // Hand tilted downwards, means 'up' in selfie view
        } else {
            newState = "front";
        }

        currentLaneState = newState; // Update the global state
        return newState;
    }

    function checkCollision(playerX, playerY, playerSize, obstacle) {
      const dx = playerX - obstacle.x;
      const dy = playerY - (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2);
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Using approximate bounding box for collision for simplicity with rect obstacles
      // Player (circle): centerX, centerY, radius
      // Obstacle (rect): x, y (top-left), width, height
      const playerRadius = playerSize / 2;
      const obstacleHalfSize = obstacle.size / 2;
      const obstacleCenterX = obstacle.x;
      const obstacleCenterY = (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2);

      // Closest point on obstacle to player center
      let testX = playerX;
      let testY = playerY;

      if (playerX < obstacleCenterX - obstacleHalfSize) testX = obstacleCenterX - obstacleHalfSize;      // left edge
      else if (playerX > obstacleCenterX + obstacleHalfSize) testX = obstacleCenterX + obstacleHalfSize;   // right edge
      if (playerY < obstacleCenterY - obstacleHalfSize) testY = obstacleCenterY - obstacleHalfSize;      // top edge
      else if (playerY > obstacleCenterY + obstacleHalfSize) testY = obstacleCenterY + obstacleHalfSize;   // bottom edge

      const distX = playerX - testX;
      const distY = playerY - testY;
      const distanceSquared = (distX * distX) + (distY * distY);

      return distanceSquared <= (playerRadius * playerRadius);
    }


    function drawGameOverlay() {
      mainCtx.save();
      mainCtx.scale(-1, 1);
      mainCtx.translate(-overlayWidth, 0);

      // Draw lanes
      mainCtx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
      mainCtx.lineWidth = 2;
      mainCtx.beginPath();
      mainCtx.moveTo(0, LANE_HEIGHT);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT);
      mainCtx.moveTo(0, LANE_HEIGHT * 2);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT * 2);
      mainCtx.stroke();

      // Move player object smoothly
      if (Math.abs(targetY - objectY) > 1) {
          objectY += (targetY - objectY) * 0.1;
      } else {
          objectY = targetY;
      }

      // Draw the player object
      mainCtx.fillStyle = '#5ad';
      mainCtx.beginPath();
      mainCtx.arc(objectX, objectY, PLAYER_SIZE / 2, 0, Math.PI * 2);
      mainCtx.fill();

      // Draw obstacles
      level.obstacles.forEach(obstacle => {
        mainCtx.fillStyle = '#e84c3d'; // Obstacle color
        mainCtx.beginPath();
        const obstacleY = LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2;
        mainCtx.rect(obstacle.x - obstacle.size / 2, obstacleY - obstacle.size / 2, obstacle.size, obstacle.size);
        mainCtx.fill();
      });

      // Draw brushing value as text (will appear un-mirrored on screen)
      mainCtx.fillStyle = '#fff';
      mainCtx.font = '20px Arial';
      mainCtx.textAlign = 'right';
      mainCtx.textBaseline = 'top';
      mainCtx.fillText(`Brushing: ${brushingValue.toFixed(2)} (Smoothed: ${smoothedBrushingImpact.toFixed(2)})`, overlayWidth - 10, 10);


      // Game Over Text or Game Won Text
      if (gameOver) {
        let message = 'GAME OVER!';
        let subMessage = 'You hit an obstacle. Click "Start camera" to play again.';
        let textColor = 'rgba(255, 0, 0, 0.7)';
        if (gameWon) {
            message = 'YOU WON!';
            subMessage = 'Congratulations! Click "Start camera" to play again.';
            textColor = 'rgba(0, 255, 0, 0.7)';
        }
        mainCtx.fillStyle = textColor;
        mainCtx.font = 'bold 48px Arial';
        mainCtx.textAlign = 'center';
        mainCtx.textBaseline = 'middle';
        mainCtx.fillText(message, overlayWidth / 2, overlayHeight / 2);
        mainCtx.font = 'bold 24px Arial';
        mainCtx.fillText(subMessage, overlayWidth / 2, overlayHeight / 2 + 40);
      }

      mainCtx.restore();
    }


    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!detector || !ui.video.videoWidth) {
        if (gameOver && ui.video.srcObject) { // Clear canvas once on game over or game won
          mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
          mainCtx.save();
          mainCtx.scale(-1, 1);
          mainCtx.translate(-overlayWidth, 0);

          let message = 'GAME OVER!';
          let subMessage = 'You hit an obstacle. Click "Start camera" to play again.';
          let textColor = 'rgba(255, 0, 0, 0.7)';
          if (gameWon) {
              message = 'YOU WON!';
              subMessage = 'Congratulations! Click "Start camera" to play again.';
              textColor = 'rgba(0, 255, 0, 0.7)';
          }

          mainCtx.fillStyle = textColor;
          mainCtx.font = 'bold 48px Arial';
          mainCtx.textAlign = 'center';
          mainCtx.textBaseline = 'middle';
          mainCtx.fillText(message, overlayWidth / 2, overlayHeight / 2);
          mainCtx.font = 'bold 24px Arial';
          mainCtx.fillText(subMessage, overlayWidth / 2, overlayHeight / 2 + 40);
          mainCtx.restore();
        }
        return; // Don't proceed if game is over or camera/detector not ready
      }
      if (gameOver) return; // Prevent game logic from running if already over

      const now = performance.now();
      if (ui.video.currentTime !== lastTime) {
        lastTime = ui.video.currentTime;

        mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
        mainCtx.drawImage(ui.video, 0, 0, overlayWidth, overlayHeight);

        const result = detector.detectForVideo(ui.video, now);
        let logLines = [];
        brushingValue *= BRUSHING_DECAY; // Apply decay to current brushing value

        let depthScale = 1.0; // Initialize depth scale

        if (result?.landmarks?.length) {
          ui.handsCount.textContent = String(result.landmarks.length);
          result.landmarks.forEach((lm, i) => {
            drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
            drawer.drawLandmarks(lm, { lineWidth: 1, radius: 3 });

            const rotation = estimateHandRotation(lm);
            const currentLaneCommand = getLaneFromPitch(rotation.pitch); // This now updates currentLaneState internally

            logLines.push(`Hand ${i+1}: Yaw: ${rotation.yaw}¬∞ Pitch: ${rotation.pitch}¬∞ Roll: ${rotation.roll}¬∞ -> Lane: ${currentLaneCommand}`);

            switch (currentLaneCommand) {
                case "up":
                    targetY = LANE_HEIGHT / 2;
                    break;
                case "down":
                    targetY = LANE_HEIGHT * 2.5;
                    break;
                case "front":
                default:
                    targetY = LANE_HEIGHT * 1.5;
                    break;
            }

            if (lm.length > 0) {
              const currentX = lm[0].x * overlayWidth;
              const currentZ = lm[0].z; // Get the Z-coordinate of the wrist landmark

              // Calculate depth scaling factor
              // If currentZ is more negative (further away), depthScale will be > 1
              // If currentZ is less negative (closer), depthScale will be < 1
              // The `DEPTH_SCALING_FACTOR` determines how sensitive this scaling is.
              depthScale = Math.pow(REFERENCE_DEPTH_Z / currentZ, DEPTH_SCALING_FACTOR);
              // Ensure depthScale doesn't become too extreme or negative
              depthScale = Math.max(0.5, Math.min(depthScale, 3.0)); // Clamp between reasonable values

              handXPositions.push(currentX);
              if (handXPositions.length > HISTORY_SIZE) {
                handXPositions.shift();
              }

              if (handXPositions.length === HISTORY_SIZE) {
                let minX = handXPositions[0];
                let maxX = handXPositions[0];
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  if (handXPositions[j] < minX) minX = handXPositions[j];
                  if (handXPositions[j] > maxX) maxX = handXPositions[j];
                }
                const range = maxX - minX;

                let totalMovement = 0;
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  totalMovement += Math.abs(handXPositions[j] - handXPositions[j-1]);
                }

                // Apply depth scaling to the brushing calculation
                const currentBrushing = ((range * 0.01) + (totalMovement * 0.005)) * depthScale;
                if (currentBrushing > brushingValue) {
                    brushingValue = currentBrushing;
                }
              }
            }
          });
        } else {
          ui.handsCount.textContent = "0";
          logLines.push("No hand detected. Defaulting to middle lane.");
          targetY = LANE_HEIGHT * 1.5;
          currentLaneState = "front"; // Reset state if hand is not detected
          handXPositions = [];
        }

        // Apply smoothing to the brushing impact
        smoothedBrushingImpact = smoothedBrushingImpact * (1 - SMOOTHING_ALPHA) + brushingValue * SMOOTHING_ALPHA;
        
        ui.brushingValue.textContent = brushingValue.toFixed(2);

        // Game logic updates
        // Move obstacles and check for collisions
        let allObstaclesPassed = true;
        for (let i = level.obstacles.length - 1; i >= 0; i--) {
          const obstacle = level.obstacles[i];
          // Use the smoothedBrushingImpact for obstacle movement
          const obstacleMovement = obstacle.speed + (smoothedBrushingImpact * BRUSHING_IMPACT_FACTOR);
          obstacle.x -= obstacleMovement;

          if (checkCollision(objectX, objectY, PLAYER_SIZE, obstacle)) {
            gameOver = true;
            ui.log.textContent = "Game Over! You hit an obstacle.";
            break;
          }

          if (obstacle.x < objectX - PLAYER_SIZE / 2 && !obstacle.passed) {
            score++;
            ui.score.textContent = score;
            obstacle.passed = true;
          }

          // Don't remove obstacles, just mark them as passed/off-screen
          // We need to keep them in the array to count total obstacles for winning condition
          if (obstacle.x > -obstacle.size) { // If it's still visible or about to be
              allObstaclesPassed = false;
          }
        }

        if (!gameOver && allObstaclesPassed && score === NUMBER_OF_OBSTACLES) {
            gameWon = true;
            gameOver = true; // Set game over to true so the win message displays
            ui.log.textContent = "Congratulations! You passed all obstacles!";
        }


        drawGameOverlay();

        frames++;
        if (now - lastFpsUpdate > 1000) {
          ui.fps.textContent = String(frames);
          frames = 0; lastFpsUpdate = now;
        }

        if (logLines.length) {
          ui.log.textContent = logLines.join("\n");
        }
      }
    }

    ui.startBtn.addEventListener('click', async () => {
      try { await startCamera(); }
      catch (err) {
        console.error(err);
        ui.log.textContent = String(err);
        ui.startBtn.disabled = false;
        setLive(false);
      }
    });
    ui.stopBtn.addEventListener('click', stopCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopCamera();
    });
  </script>
</body>
</html>