<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lane Control ‚Äî MediaPipe Hand Posture</title>
  <style>
    :root { --bg:#0b1020; --fg:#e8eef7; --accent:#5ad; --muted:#a8b3c7; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg); background: radial-gradient(1200px 600px at 20% -10%, #1a2340 0%, #0b1020 50%, #060914 100%);
      min-height: 100dvh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(960px, 95vw);
      background: #101933cc; backdrop-filter: blur(6px);
      border: 1px solid #1e2a4d; border-radius: 18px; box-shadow: 0 15px 60px rgba(0,0,0,.35);
      padding: 18px 18px 12px; position: relative;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 3fr 2fr; } }
    h1 {
      margin: 2px 0 8px; font-weight: 700; letter-spacing: .2px;
      font-size: clamp(18px, 2.3vw, 26px);
      display:flex; align-items:center; gap:10px;
    }
    .badge { font-size: 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button {
      appearance: none; border: 1px solid #355; background: #0e1a33; color: var(--fg);
      padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: linear-gradient(180deg, #2b6cff, #1d54c9); border-color: #1d54c9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill {
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3c69;
      border-radius: 999px; color: var(--muted); font-size: 12px;
    }
    .stage {
      position: relative; width: 100%; aspect-ratio: 16 / 9;
      background: #060a18; border:1px solid #1b294f; border-radius:14px; overflow:hidden;
      display: flex; justify-content: center; align-items: center;
    }
    #gameCanvas {
      background: #101933;
      border: 1px solid #2a3c69;
      border-radius: 8px;
    }
    video, canvas { position: absolute; inset: 0; width:100%; height:100%; }
    video { transform: scaleX(-1); }
    canvas { pointer-events:none; }
    .watermark {
      position:absolute; top:8px; right:10px; font-size:12px; color:#cfe3ff; opacity:.8;
      background:#0b1430aa; padding:6px 8px; border-radius:10px; border:1px solid #1e2a4d;
    }
    .log {
      padding: 10px 12px; border:1px dashed #28407a; border-radius:12px; color: #c9d7ee; background:#0d162e;
      min-height: 64px; white-space:pre-wrap;
    }
    a { color:#9bd; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#7f8; box-shadow:0 0 0 3px #122; }
  </style>
</head>
<body>
  <div class="card">
    <h1>‚úã Lane Control <span class="badge">‚Äî MediaPipe Hand Posture</span></h1>
    <div class="toolbar">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" disabled>Stop camera</button>
      <span class="pill"><span class="dot" id="dot"></span><span id="status">idle</span></span>
      <span class="pill" title="frames per second">FPS: <strong id="fps">0</strong></span>
      <span class="pill">Hands: <strong id="handsCount">0</strong></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="stage">
        <video id="video" playsinline muted style="display:none;"></video>
        <canvas id="overlay" style="display:none;"></canvas>
        <canvas id="gameCanvas" width="640" height="360"></canvas>
        <div class="watermark">Hand landmarks + connections (hidden)</div>
      </div>
      <div class="log" id="log">Click ‚ÄúStart camera‚Äù, allow permission, then hold your hand up üñêÔ∏è.
        Tilt your hand up for the top lane.
        Tilt your hand down for the bottom lane.
        Hold it flat for the middle lane.
      </div>
    </div>

    <footer>
      Tip: This runs fully in your browser. Use HTTPS or localhost for camera access. Model provided by Google‚Äôs MediaPipe Hand Landmarker.
    </footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      dot: document.getElementById('dot'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      handsCount: document.getElementById('handsCount'),
      log: document.getElementById('log'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
      gameCanvas: document.getElementById('gameCanvas'),
    };

    let stream;
    let detector;
    let rafId = 0;
    let lastTime = 0, frames = 0, lastFpsUpdate = 0;

    const overlayCtx = ui.overlay.getContext('2d');
    const gameCtx = ui.gameCanvas.getContext('2d');
    const drawer = new DrawingUtils(overlayCtx);

    // Game state variables
    const LANE_HEIGHT = ui.gameCanvas.height / 3;
    const OBJECT_SIZE = 40;
    let objectY = LANE_HEIGHT / 2; // Start in middle lane (will be updated by gesture)
    let targetY = objectY;
    let objectX = ui.gameCanvas.width / 4;
    const OBJECT_SPEED = 5;

    function setStatus(text){ ui.status.textContent = text; }
    function setLive(on){
      ui.dot.style.background = on ? '#7f8' : '#f88';
      setStatus(on ? 'live' : 'idle');
    }

    async function initDetector(){
      setStatus('loading model‚Ä¶');
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      detector = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    async function startCamera(){
      if (!detector) await initDetector();
      ui.startBtn.disabled = true;
      ui.stopBtn.disabled = false;
      setLive(true);

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 960 }, height: { ideal: 540 } },
        audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();

      ui.overlay.width = ui.video.videoWidth;
      ui.overlay.height = ui.video.videoHeight;

      lastTime = -1; frames = 0; lastFpsUpdate = performance.now();
      loop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      overlayCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
      ui.video.srcObject = null;
      ui.startBtn.disabled = false;
      ui.stopBtn.disabled = true;
      setLive(false);
      ui.handsCount.textContent = "0";
      ui.fps.textContent = "0";

      gameCtx.clearRect(0, 0, ui.gameCanvas.width, ui.gameCanvas.height);
    }

    // Function to estimate yaw, pitch, and roll based on hand posture
    // This is from the previous version, adapted for lane control.
    function estimateHandRotation(landmarks) {
      // Using wrist (0), middle finger MCP (9), and pinky MCP (17) for a basic plane
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      const pinkyMcp = landmarks[17];

      // Vector along the presumed object's axis (from wrist towards middle finger base if hand is closed)
      const vecObjAxisX = middleMcp.x - wrist.x;
      const vecObjAxisY = middleMcp.y - wrist.y;
      const vecObjAxisZ = middleMcp.z - wrist.z;

      // Normalizing the vector
      const mag = Math.sqrt(vecObjAxisX*vecObjAxisX + vecObjAxisY*vecObjAxisY + vecObjAxisZ*vecObjAxisZ);
      const normalX = vecObjAxisX / mag;
      const normalY = vecObjAxisY / mag;
      const normalZ = vecObjAxisZ / mag;

      // Yaw (rotation around Y-axis) - looking left/right
      const yaw = Math.atan2(normalX, -normalZ) * (180 / Math.PI); // -Z for forward

      // Pitch (rotation around X-axis) - pointing up/down
      const pitch = Math.atan2(normalY, Math.sqrt(normalX * normalX + normalZ * normalZ)) * (180 / Math.PI);

      // Roll (rotation around Z-axis) - twisting
      const vecSideX = pinkyMcp.x - wrist.x; // Using pinky-wrist for a side vector
      const vecSideY = pinkyMcp.y - wrist.y;
      const roll = Math.atan2(vecSideY, vecSideX) * (180 / Math.PI);

      return {
        yaw: parseFloat(yaw.toFixed(2)),
        pitch: parseFloat(pitch.toFixed(2)),
        roll: parseFloat(roll.toFixed(2)),
      };
    }

    // Function to map pitch to lane
    function getLaneFromPitch(pitch) {
        // These thresholds will likely need tuning based on how you hold your hand.
        // Positive pitch typically means pointing downwards.
        // Negative pitch typically means pointing upwards.
        const UP_PITCH_THRESHOLD = 40; // e.g., if hand points up by > 20 degrees
        const DOWN_PITCH_THRESHOLD = -40; // e.g., if hand points down by > 20 degrees

        if (pitch > UP_PITCH_THRESHOLD) {
            return "up";
        } else if (pitch < DOWN_PITCH_THRESHOLD) {
            return "down";
        } else {
            return "front"; // Neutral/flat hand
        }
    }


    // Function to draw the game state
    function drawGame() {
      gameCtx.clearRect(0, 0, ui.gameCanvas.width, ui.gameCanvas.height);

      // Draw lanes
      gameCtx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
      gameCtx.lineWidth = 2;
      gameCtx.beginPath();
      gameCtx.moveTo(0, LANE_HEIGHT);
      gameCtx.lineTo(ui.gameCanvas.width, LANE_HEIGHT);
      gameCtx.moveTo(0, LANE_HEIGHT * 2);
      gameCtx.lineTo(ui.gameCanvas.width, LANE_HEIGHT * 2);
      gameCtx.stroke();

      // Move object smoothly
      if (Math.abs(targetY - objectY) > 1) {
          objectY += (targetY - objectY) * 0.1; // Easing function
      } else {
          objectY = targetY;
      }

      // Draw the object
      gameCtx.fillStyle = '#5ad';
      gameCtx.beginPath();
      gameCtx.arc(objectX, objectY, OBJECT_SIZE / 2, 0, Math.PI * 2);
      gameCtx.fill();
    }

    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!detector || !ui.video.videoWidth) return;

      const now = performance.now();
      if (ui.video.currentTime !== lastTime) {
        lastTime = ui.video.currentTime;

        const result = detector.detectForVideo(ui.video, now);

        overlayCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
        let logLines = [];

        if (result?.landmarks?.length) {
          ui.handsCount.textContent = String(result.landmarks.length);
          result.landmarks.forEach((lm, i) => {
            drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
            drawer.drawLandmarks(lm, { lineWidth: 1, radius: 3 });

            // Use the rotation estimation from the previous version
            const rotation = estimateHandRotation(lm);
            const currentLaneCommand = getLaneFromPitch(rotation.pitch);

            logLines.push(`Hand ${i+1}: Yaw: ${rotation.yaw}¬∞ Pitch: ${rotation.pitch}¬∞ Roll: ${rotation.roll}¬∞ -> Lane: ${currentLaneCommand}`);

            // Logic to move the object to the chosen lane based on pitch
            switch (currentLaneCommand) {
                case "up":
                    targetY = LANE_HEIGHT / 2; // Top lane center
                    break;
                case "down":
                    targetY = LANE_HEIGHT * 2.5; // Bottom lane center
                    break;
                case "front":
                default:
                    targetY = LANE_HEIGHT * 1.5; // Middle lane center
                    break;
            }
          });
        } else {
          ui.handsCount.textContent = "0";
          logLines.push("No hand detected. Defaulting to middle lane.");
          targetY = LANE_HEIGHT * 1.5; // Default to middle lane if no hand
        }

        drawGame();

        frames++;
        if (now - lastFpsUpdate > 1000) {
          ui.fps.textContent = String(frames);
          frames = 0; lastFpsUpdate = now;
        }

        if (logLines.length) {
          ui.log.textContent = logLines.join("\n");
        }
      }
    }

    ui.startBtn.addEventListener('click', async () => {
      try { await startCamera(); }
      catch (err) {
        console.error(err);
        ui.log.textContent = String(err);
        ui.startBtn.disabled = false;
        setLive(false);
      }
    });
    ui.stopBtn.addEventListener('click', stopCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopCamera();
    });
  </script>
</body>
</html>