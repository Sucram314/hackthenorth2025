<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lane Control ‚Äî MediaPipe Hand Posture</title>
  <style>
    :root { --bg:#0b1020; --fg:#e8eef7; --accent:#5ad; --muted:#a8b3c7; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg); background: radial-gradient(1200px 600px at 20% -10%, #1a2340 0%, #0b1020 50%, #060914 100%);
      min-height: 100dvh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(960px, 95vw);
      background: #101933cc; backdrop-filter: blur(6px);
      border: 1px solid #1e2a4d; border-radius: 18px; box-shadow: 0 15px 60px rgba(0,0,0,.35);
      padding: 18px 18px 12px; position: relative;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 3fr 2fr; } }
    h1 {
      margin: 2px 0 8px; font-weight: 700; letter-spacing: .2px;
      font-size: clamp(18px, 2.3vw, 26px);
      display:flex; align-items:center; gap:10px;
    }
    .badge { font-size: 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button {
      appearance: none; border: 1px solid #355; background: #0e1a33; color: var(--fg);
      padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: linear-gradient(180deg, #2b6cff, #1d54c9); border-color: #1d54c9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill {
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3c69;
      border-radius: 999px; color: var(--muted); font-size: 12px;
    }
    .stage {
      position: relative; width: 100%; aspect-ratio: 16 / 9;
      background: #060a18; border:1px solid #1b294f; border-radius:14px; overflow:hidden;
      display: flex; justify-content: center; align-items: center;
    }
    /* Only the video will be truly hidden if we draw on overlay */
    video { transform: scaleX(-1); position:absolute; top:0; left:0; width:100%; height:100%; object-fit: cover; }
    /* The overlay canvas will now be our main display */
    #overlay {
      position: absolute; inset: 0; width:100%; height:100%;
      pointer-events: none; /* Allow interaction with elements behind if any */
      transform: scaleX(-1); /* Mirror the canvas content to match video selfie view */
    }
    /* We no longer need a separate gameCanvas */
    #gameCanvas {
      display: none; /* Hide the gameCanvas as we're drawing on overlay */
    }
    .watermark {
      position:absolute; top:8px; right:10px; font-size:12px; color:#cfe3ff; opacity:.8;
      background:#0b1430aa; padding:6px 8px; border-radius:10px; border:1px solid #1e2a4d;
      z-index: 10; /* Ensure watermark is on top */
      transform: scaleX(-1); /* Un-mirror watermark text */
    }
    .log {
      padding: 10px 12px; border:1px dashed #28407a; border-radius:12px; color: #c9d7ee; background:#0d162e;
      min-height: 64px; white-space:pre-wrap;
    }
    a { color:#9bd; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#7f8; box-shadow:0 0 0 3px #122; }
  </style>
</head>
<body>
  <div class="card">
    <h1>‚úã Lane Control <span class="badge">‚Äî MediaPipe Hand Posture</span></h1>
    <div class="toolbar">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" disabled>Stop camera</button>
      <span class="pill"><span class="dot" id="dot"></span><span id="status">idle</span></span>
      <span class="pill" title="frames per second">FPS: <strong id="fps">0</strong></span>
      <span class="pill">Hands: <strong id="handsCount">0</strong></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="stage">
        <!-- The video element will now be the background source for the canvas -->
        <video id="video" playsinline muted></video>
        <!-- The overlay canvas will now draw everything: video, landmarks, and game -->
        <canvas id="overlay"></canvas>
        <!-- The dedicated gameCanvas is no longer needed -->
        <canvas id="gameCanvas" width="640" height="360" style="display:none;"></canvas>
        <div class="watermark">Hand landmarks + game overlay</div>
      </div>
      <div class="log" id="log">Click ‚ÄúStart camera‚Äù, allow permission, then hold your hand up üñêÔ∏è.
        Tilt your hand up for the top lane.
        Tilt your hand down for the bottom lane.
        Hold it flat for the middle lane.
      </div>
    </div>

    <footer>
      Tip: This runs fully in your browser. Use HTTPS or localhost for camera access. Model provided by Google‚Äôs MediaPipe Hand Landmarker.
    </footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      dot: document.getElementById('dot'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      handsCount: document.getElementById('handsCount'),
      log: document.getElementById('log'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'), // This is now the main drawing canvas
      // gameCanvas is no longer directly used for drawing
    };

    let stream;
    let detector;
    let rafId = 0;
    let lastTime = 0, frames = 0, lastFpsUpdate = 0;

    const mainCtx = ui.overlay.getContext('2d'); // Use overlayCtx as the main context
    const drawer = new DrawingUtils(mainCtx);

    // Game state variables
    // Now these values need to be relative to the overlay canvas dimensions
    let overlayWidth = 0;
    let overlayHeight = 0;
    const GAME_AREA_WIDTH = 640; // Maintain conceptual game area dimensions
    const GAME_AREA_HEIGHT = 360;

    let LANE_HEIGHT = GAME_AREA_HEIGHT / 3;
    const OBJECT_SIZE = 40;
    let objectY = LANE_HEIGHT / 2;
    let targetY = objectY;
    let objectX = GAME_AREA_WIDTH / 4;
    const OBJECT_SPEED = 5;

    function setStatus(text){ ui.status.textContent = text; }
    function setLive(on){
      ui.dot.style.background = on ? '#7f8' : '#f88';
      setStatus(on ? 'live' : 'idle');
    }

    async function initDetector(){
      setStatus('loading model‚Ä¶');
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      detector = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    async function startCamera(){
      if (!detector) await initDetector();
      ui.startBtn.disabled = true;
      ui.stopBtn.disabled = false;
      setLive(true);

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 960 }, height: { ideal: 540 } },
        audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();

      // Set overlay canvas dimensions to match video
      overlayWidth = ui.video.videoWidth;
      overlayHeight = ui.video.videoHeight;
      ui.overlay.width = overlayWidth;
      ui.overlay.height = overlayHeight;

      // Update LANE_HEIGHT based on actual overlay height
      LANE_HEIGHT = overlayHeight / 3;
      objectY = LANE_HEIGHT / 2; // Reset initial position
      targetY = objectY;
      objectX = overlayWidth / 4; // Position object on the left, scaled to overlay width

      lastTime = -1; frames = 0; lastFpsUpdate = performance.now();
      loop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      mainCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
      ui.video.srcObject = null;
      ui.startBtn.disabled = false;
      ui.stopBtn.disabled = true;
      setLive(false);
      ui.handsCount.textContent = "0";
      ui.fps.textContent = "0";
    }

    // Function to estimate yaw, pitch, and roll based on hand posture
    function estimateHandRotation(landmarks) {
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      const pinkyMcp = landmarks[17];

      const vecObjAxisX = middleMcp.x - wrist.x;
      const vecObjAxisY = middleMcp.y - wrist.y;
      const vecObjAxisZ = middleMcp.z - wrist.z;

      const mag = Math.sqrt(vecObjAxisX*vecObjAxisX + vecObjAxisY*vecObjAxisY + vecObjAxisZ*vecObjAxisZ);
      const normalX = vecObjAxisX / mag;
      const normalY = vecObjAxisY / mag;
      const normalZ = vecObjAxisZ / mag;

      const yaw = Math.atan2(normalX, -normalZ) * (180 / Math.PI);
      const pitch = Math.atan2(normalY, Math.sqrt(normalX * normalX + normalZ * normalZ)) * (180 / Math.PI);

      const vecSideX = pinkyMcp.x - wrist.x;
      const vecSideY = pinkyMcp.y - wrist.y;
      const roll = Math.atan2(vecSideY, vecSideX) * (180 / Math.PI);

      return {
        yaw: parseFloat(yaw.toFixed(2)),
        pitch: parseFloat(pitch.toFixed(2)),
        roll: parseFloat(roll.toFixed(2)),
      };
    }

    // Function to map pitch to lane
    function getLaneFromPitch(pitch) {
        // Swapped UP and DOWN conditions
        const UP_PITCH_THRESHOLD = -60;
        const DOWN_PITCH_THRESHOLD = 20;

        if (pitch < UP_PITCH_THRESHOLD) {
            return "down"; // Was "up", now "down"
        } else if (pitch > DOWN_PITCH_THRESHOLD) {
            return "up"; // Was "down", now "up"
        } else {
            return "front";
        }
    }

    // Function to draw the game state on the main canvas (overlayCtx)
    function drawGameOverlay() {
      // Game drawing logic needs to consider the mainCtx's coordinate system
      // and ensure it scales correctly within the video frame.

      // We need to un-mirror the drawing for game elements
      mainCtx.save();
      // The overlay canvas is already transformed with scaleX(-1) in CSS.
      // To draw content correctly, we need to temporarily reverse this transformation
      // or draw as if the canvas is not mirrored, and then apply the mirroring
      // after the fact. The current CSS transform handles the overall mirroring.
      // For drawing internal elements, we should draw them as they appear logically.
      // The `transform: scaleX(-1);` on #overlay means anything drawn on it
      // will be mirrored. If we want our *game elements* to appear un-mirrored,
      // we need to draw them in a way that compensates for this.

      // Option 1: Apply an inverse transform to the context
      mainCtx.scale(-1, 1); // Apply an inverse mirror to draw content un-mirrored
      mainCtx.translate(-overlayWidth, 0); // Translate back to keep content in view

      // Draw lanes (scaled to overlay dimensions)
      mainCtx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
      mainCtx.lineWidth = 2;
      mainCtx.beginPath();
      mainCtx.moveTo(0, LANE_HEIGHT);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT);
      mainCtx.moveTo(0, LANE_HEIGHT * 2);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT * 2);
      mainCtx.stroke();

      // Move object smoothly
      if (Math.abs(targetY - objectY) > 1) {
          objectY += (targetY - objectY) * 0.1;
      } else {
          objectY = targetY;
      }

      // Draw the object (scaled to overlay dimensions)
      mainCtx.fillStyle = '#5ad';
      mainCtx.beginPath();
      // objectX and objectY should now be directly in overlay coordinates
      mainCtx.arc(objectX, objectY, OBJECT_SIZE / 2, 0, Math.PI * 2);
      mainCtx.fill();

      mainCtx.restore(); // Restore context to original (CSS-mirrored) state for landmarks
    }


    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!detector || !ui.video.videoWidth) return;

      const now = performance.now();
      if (ui.video.currentTime !== lastTime) {
        lastTime = ui.video.currentTime;

        // Clear the canvas for the new frame
        mainCtx.clearRect(0,0,overlayWidth, overlayHeight);

        // 1. Draw the video frame as the background
        // The video element itself is mirrored by CSS: `video { transform: scaleX(-1); }`
        // When drawing it to the canvas, we draw it normally. The #overlay canvas's CSS
        // `transform: scaleX(-1);` will mirror the entire canvas content, including the video drawn on it.
        mainCtx.drawImage(ui.video, 0, 0, overlayWidth, overlayHeight);


        // 2. Detect hand landmarks
        const result = detector.detectForVideo(ui.video, now);

        let logLines = [];

        if (result?.landmarks?.length) {
          ui.handsCount.textContent = String(result.landmarks.length);
          result.landmarks.forEach((lm, i) => {
            // 3. Draw hand landmarks over the video
            // The `DrawingUtils` class automatically handles the `transform: scaleX(-1)`
            // of the canvas if the context is passed to it, so landmarks will appear
            // correctly overlaid on the mirrored video.
            drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
            drawer.drawLandmarks(lm, { lineWidth: 1, radius: 3 });

            // Estimate hand rotation
            const rotation = estimateHandRotation(lm);
            const currentLaneCommand = getLaneFromPitch(rotation.pitch);

            logLines.push(`Hand ${i+1}: Yaw: ${rotation.yaw}¬∞ Pitch: ${rotation.pitch}¬∞ Roll: ${rotation.roll}¬∞ -> Lane: ${currentLaneCommand}`);

            // Logic to move the object to the chosen lane based on pitch
            switch (currentLaneCommand) {
                case "up":
                    targetY = LANE_HEIGHT / 2;
                    break;
                case "down":
                    targetY = LANE_HEIGHT * 2.5;
                    break;
                case "front":
                default:
                    targetY = LANE_HEIGHT * 1.5;
                    break;
            }
          });
        } else {
          ui.handsCount.textContent = "0";
          logLines.push("No hand detected. Defaulting to middle lane.");
          targetY = LANE_HEIGHT * 1.5;
        }

        // 4. Draw the game elements over the hand wireframe
        drawGameOverlay();

        frames++;
        if (now - lastFpsUpdate > 1000) {
          ui.fps.textContent = String(frames);
          frames = 0; lastFpsUpdate = now;
        }

        if (logLines.length) {
          ui.log.textContent = logLines.join("\n");
        }
      }
    }

    ui.startBtn.addEventListener('click', async () => {
      try { await startCamera(); }
      catch (err) {
        console.error(err);
        ui.log.textContent = String(err);
        ui.startBtn.disabled = false;
        setLive(false);
      }
    });
    ui.stopBtn.addEventListener('click', stopCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopCamera();
    });
  </script>
</body>
</html>