<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lane Control ‚Äî MediaPipe Hand Posture</title>
  <style>
    :root { --bg:#0b1020; --fg:#e8eef7; --accent:#5ad; --muted:#a8b3c7; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg); background: radial-gradient(1200px 600px at 20% -10%, #1a2340 0%, #0b1020 50%, #060914 100%);
      min-height: 100dvh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(960px, 95vw);
      background: #101933cc; backdrop-filter: blur(6px);
      border: 1px solid #1e2a4d; border-radius: 18px; box-shadow: 0 15px 60px rgba(0,0,0,.35);
      padding: 18px 18px 12px; position: relative;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 3fr 2fr; } }
    h1 {
      margin: 2px 0 8px; font-weight: 700; letter-spacing: .2px;
      font-size: clamp(18px, 2.3vw, 26px);
      display:flex; align-items:center; gap:10px;
    }
    .badge { font-size: 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button {
      appearance: none; border: 1px solid #355; background: #0e1a33; color: var(--fg);
      padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: linear-gradient(180deg, #2b6cff, #1d54c9); border-color: #1d54c9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill {
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3c69;
      border-radius: 999px; color: var(--muted); font-size: 12px;
    }
    .stage {
      position: relative; width: 100%; aspect-ratio: 16 / 9;
      background: #060a18; border:1px solid #1b294f; border-radius:14px; overflow:hidden;
      display: flex; justify-content: center; align-items: center;
    }
    /* Only the video will be truly hidden if we draw on overlay */
    video { transform: scaleX(-1); position:absolute; top:0; left:0; width:100%; height:100%; object-fit: cover; }
    /* The overlay canvas will now be our main display */
    #overlay {
      position: absolute; inset: 0; width:100%; height:100%;
      pointer-events: none; /* Allow interaction with elements behind if any */
      transform: scaleX(-1); /* Mirror the canvas content to match video selfie view */
    }
    /* We no longer need a separate gameCanvas */
    #gameCanvas {
      display: none; /* Hide the gameCanvas as we're drawing on overlay */
    }
    .watermark {
      position:absolute; top:8px; right:10px; font-size:12px; color:#cfe3ff; opacity:.8;
      background:#0b1430aa; padding:6px 8px; border-radius:10px; border:1px solid #1e2a4d;
      z-index: 10; /* Ensure watermark is on top */
      transform: scaleX(-1); /* Un-mirror watermark text */
    }
    .log {
      padding: 10px 12px; border:1px dashed #28407a; border-radius:12px; color: #c9d7ee; background:#0d162e;
      min-height: 64px; white-space:pre-wrap;
    }
    a { color:#9bd; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#7f8; box-shadow:0 0 0 3px #122; }
  </style>
</head>
<body>
  <div class="card">
    <h1>‚úã Lane Control <span class="badge">‚Äî MediaPipe Hand Posture</span></h1>
    <div class="toolbar">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" disabled>Stop camera</button>
      <span class="pill"><span class="dot" id="dot"></span><span id="status">idle</span></span>
      <span class="pill" title="frames per second">FPS: <strong id="fps">0</strong></span>
      <span class="pill">Hands: <strong id="handsCount">0</strong></span>
      <span class="pill">Brushing: <strong id="brushingValue">0.00</strong></span>
      <span class="pill">Score: <strong id="score">0</strong>/<strong id="totalObstacles">0</strong></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="stage">
        <!-- The video element will now be the background source for the canvas -->
        <video id="video" playsinline muted></video>
        <!-- The overlay canvas will now draw everything: video, landmarks, and game -->
        <canvas id="overlay"></canvas>
        <!-- The dedicated gameCanvas is no longer needed -->
        <canvas id="gameCanvas" width="640" height="360" style="display:none;"></canvas>
        <div class="watermark">Hand landmarks + game overlay</div>
      </div>
      <div class="log" id="log">Click ‚ÄúStart camera‚Äù, allow permission, then hold your hand up üñêÔ∏è.
        Tilt your hand up for the top lane.
        Tilt your hand down for the bottom lane.
        Hold it flat for the middle lane.
        Brush your hand back and forth horizontally to make obstacles move faster!
      </div>
    </div>

    <footer>
      Tip: This runs fully in your browser. Use HTTPS or localhost for camera access. Model provided by Google‚Äôs MediaPipe Hand Landmarker.
    </footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      dot: document.getElementById('dot'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      handsCount: document.getElementById('handsCount'),
      brushingValue: document.getElementById('brushingValue'),
      score: document.getElementById('score'),
      totalObstacles: document.getElementById('totalObstacles'), // New UI element
      log: document.getElementById('log'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
    };

    let stream;
    let detector;
    let rafId = 0;
    let lastTime = 0, frames = 0, lastFpsUpdate = 0;

    const mainCtx = ui.overlay.getContext('2d');
    const drawer = new DrawingUtils(mainCtx);

    let overlayWidth = 0;
    let overlayHeight = 0;

    let LANE_HEIGHT;
    const PLAYER_SIZE = 40;
    let objectY;
    let targetY;
    let objectX;
    let lastValidTargetY; // New variable to store the last valid targetY

    // Brushing detection variables
    const HISTORY_SIZE = 10;
    let handXPositions = [];
    let brushingValue = 0;
    const BRUSHING_DECAY = 0.9;
    const BRUSHING_IMPACT_FACTOR = 3; // How much brushing affects obstacle speed
    let smoothedBrushingImpact = 0; // New variable for smoothed impact
    const SMOOTHING_ALPHA = 0.1; // Smoothing factor (0 to 1, lower = more smooth)
    
    // Depth-based scaling variables
    const REFERENCE_DEPTH_Z = -0.1; // A typical Z-value for a hand at a "normal" distance (experiment with this)
    const DEPTH_SCALING_FACTOR = 1; // How strongly distance affects the scale (adjust as needed)

    // Game state variables
    let score = 0;
    let gameOver = false;
    let gameWon = false; // New game state variable
    let currentLaneState = "front"; // To keep track of the current hand posture state

    // Level definition and state
    const NUMBER_OF_OBSTACLES = 10; // Fixed number of obstacles for the level
    const OBSTACLE_SPACING_DISTANCE = 500; // Distance between obstacles (in pixels)
    const OBSTACLE_HEIGHT = 60; // Fixed height for obstacles
    let level = {
      obstacles: [],
      baseObstacleSpeed: 2, // Base speed for obstacles
      lanes: [0, 1, 2] // Lane indices
    };

    function setStatus(text){ ui.status.textContent = text; }
    function setLive(on){
      ui.dot.style.background = on ? '#7f8' : '#f88';
      setStatus(on ? 'live' : 'idle');
    }

    async function initDetector(){
      setStatus('loading model‚Ä¶');
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      detector = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    async function startCamera(){
      if (!detector) await initDetector();
      ui.startBtn.disabled = true;
      ui.stopBtn.disabled = false;
      setLive(true);
      gameOver = false;
      gameWon = false; // Reset game won state
      score = 0;
      ui.score.textContent = score;

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 960 }, height: { ideal: 540 } },
        audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();

      overlayWidth = ui.video.videoWidth;
      overlayHeight = ui.video.videoHeight;
      ui.overlay.width = overlayWidth;
      ui.overlay.height = overlayHeight;

      LANE_HEIGHT = overlayHeight / 3;
      objectY = LANE_HEIGHT * 1.5;
      targetY = objectY;
      objectX = overlayWidth / 4;
      lastValidTargetY = targetY; // Initialize lastValidTargetY

      handXPositions = [];
      brushingValue = 0;
      smoothedBrushingImpact = 0; // Initialize smoothed value
      currentLaneState = "front"; // Reset state on camera start

      // Initialize obstacles based on number and spacing
      level.obstacles = [];
      ui.totalObstacles.textContent = NUMBER_OF_OBSTACLES;
      const obstacleTypes = [
          { type: 'car', multiplier: 2, color: '#e84c3d' }, // Red car
          { type: 'truck', multiplier: 3, color: '#f1c40f' }, // Yellow truck
          { type: 'train', multiplier: 4, color: '#3498db' }  // Blue train
      ];

      for (let i = 0; i < NUMBER_OF_OBSTACLES; i++) {
        const randomLane = level.lanes[Math.floor(Math.random() * level.lanes.length)];
        const randomObstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        const obstacleWidth = OBSTACLE_HEIGHT * randomObstacleType.multiplier;

        level.obstacles.push({
          lane: randomLane,
          x: overlayWidth + (i * OBSTACLE_SPACING_DISTANCE) + obstacleWidth, // Space them out initially
          speed: level.baseObstacleSpeed,
          height: OBSTACLE_HEIGHT, // Fixed height
          width: obstacleWidth,    // Variable width
          color: randomObstacleType.color,
          type: randomObstacleType.type,
          passed: false
        });
      }

      lastTime = -1; frames = 0; lastFpsUpdate = performance.now();
      loop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      mainCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
      ui.video.srcObject = null;
      ui.startBtn.disabled = false;
      ui.stopBtn.disabled = true;
      setLive(false);
      ui.handsCount.textContent = "0";
      ui.fps.textContent = "0";
      ui.brushingValue.textContent = "0.00";
      gameOver = true;
    }

    function estimateHandRotation(landmarks) {
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      const pinkyMcp = landmarks[17];

      const vecUpX = middleMcp.x - wrist.x;
      const vecUpY = middleMcp.y - wrist.y;
      const vecUpZ = middleMcp.z - wrist.z;

      const magUp = Math.sqrt(vecUpX*vecUpX + vecUpY*vecUpY + vecUpZ*vecUpZ);
      const normUpY = vecUpY / magUp;

      const pitch = Math.asin(normUpY) * (180 / Math.PI);

      const vecSideX = pinkyMcp.x - wrist.x;
      const vecSideY = pinkyMcp.y - wrist.y;
      const roll = Math.atan2(vecSideY, vecSideX) * (180 / Math.PI);

      const yaw = Math.atan2(vecUpX, -vecUpZ) * (180 / Math.PI);

      return {
        yaw: parseFloat(yaw.toFixed(2)),
        pitch: parseFloat(pitch.toFixed(2)),
        roll: parseFloat(roll.toFixed(2)),
      };
    }

    function getLaneFromPitch(pitch) {
        // Define base thresholds
        const BASE_UP_THRESHOLD = -60;
        const BASE_DOWN_THRESHOLD = 30;

        // Define hysteresis bias
        const HYSTERESIS_BIAS = 10; // degrees

        let upThreshold = BASE_UP_THRESHOLD;
        let downThreshold = BASE_DOWN_THRESHOLD;

        // Apply bias based on current state
        if (currentLaneState === "up") {
            // To go from "up" to "front", pitch must be greater than BASE_UP_THRESHOLD + BIAS
            upThreshold = BASE_UP_THRESHOLD + HYSTERESIS_BIAS;
        } else if (currentLaneState === "down") {
            // To go from "down" to "front", pitch must be less than BASE_DOWN_THRESHOLD - BIAS
            downThreshold = BASE_DOWN_THRESHOLD - HYSTERESIS_BIAS;
        } else if (currentLaneState === "front") {
            // To go from "front" to "up", pitch must be less than BASE_UP_THRESHOLD - BIAS
            // To go from "front" to "down", pitch must be greater than BASE_DOWN_THRESHOLD + BIAS
            upThreshold = BASE_UP_THRESHOLD - HYSTERESIS_BIAS;
            downThreshold = BASE_DOWN_THRESHOLD + HYSTERESIS_BIAS;
        }

        let newState;
        if (pitch < upThreshold) {
            newState = "down"; // Hand tilted upwards, means 'down' in selfie view
        } else if (pitch > downThreshold) {
            newState = "up"; // Hand tilted downwards, means 'up' in selfie view
        } else {
            newState = "front";
        }

        currentLaneState = newState; // Update the global state
        return newState;
    }

    function checkCollision(playerX, playerY, playerSize, obstacle) {
      // Player (circle): centerX, centerY, radius
      const playerRadius = playerSize / 2;
      const playerTop = playerY - playerRadius;
      const playerBottom = playerY + playerRadius;
      const playerLeft = playerX - playerRadius;
      const playerRight = playerX + playerRadius;

      // Obstacle (rectangle): x (center), y (center), width, height
      const obstacleTop = (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2) - obstacle.height / 2;
      const obstacleBottom = (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2) + obstacle.height / 2;
      const obstacleLeft = obstacle.x - obstacle.width / 2;
      const obstacleRight = obstacle.x + obstacle.width / 2;

      // Check for overlap on X axis
      const xOverlap = Math.max(0, Math.min(playerRight, obstacleRight) - Math.max(playerLeft, obstacleLeft));
      // Check for overlap on Y axis
      const yOverlap = Math.max(0, Math.min(playerBottom, obstacleBottom) - Math.max(playerTop, obstacleTop));

      // If both overlaps are greater than 0, there is a collision
      return xOverlap > 0 && yOverlap > 0;
    }


    function drawGameOverlay() {
      mainCtx.save();
      mainCtx.scale(-1, 1);
      mainCtx.translate(-overlayWidth, 0);

      // Draw lanes
      mainCtx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
      mainCtx.lineWidth = 2;
      mainCtx.beginPath();
      mainCtx.moveTo(0, LANE_HEIGHT);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT);
      mainCtx.moveTo(0, LANE_HEIGHT * 2);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT * 2);
      mainCtx.stroke();

      // Move player object smoothly
      if (Math.abs(targetY - objectY) > 1) {
          objectY += (targetY - objectY) * 0.1;
      } else {
          objectY = targetY;
      }

      // Draw the player object
      mainCtx.fillStyle = '#5ad';
      mainCtx.beginPath();
      mainCtx.arc(objectX, objectY, PLAYER_SIZE / 2, 0, Math.PI * 2);
      mainCtx.fill();

      // Draw obstacles
      level.obstacles.forEach(obstacle => {
        const obstacleYCenter = LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2;
        const obstacleX = obstacle.x - obstacle.width / 2; // Top-left X for drawing
        const obstacleY = obstacleYCenter - obstacle.height / 2; // Top-left Y for drawing

        mainCtx.fillStyle = obstacle.color;
        mainCtx.fillRect(obstacleX, obstacleY, obstacle.width, obstacle.height);

        // Draw additional shapes based on obstacle type
        if (obstacle.type === 'car') {
            mainCtx.fillStyle = 'rgba(0,0,0,0.5)'; // Darker color for car details
            // Windshield
            mainCtx.fillRect(obstacleX + obstacle.width * 0.2, obstacleY + obstacle.height * 0.1, obstacle.width * 0.6, obstacle.height * 0.3);
            // Rear window
            mainCtx.fillRect(obstacleX + obstacle.width * 0.2, obstacleY + obstacle.height * 0.6, obstacle.width * 0.6, obstacle.height * 0.3);
            // Wheels (simplified circles)
            mainCtx.fillStyle = '#333';
            mainCtx.beginPath();
            mainCtx.arc(obstacleX + obstacle.width * 0.15, obstacleY + obstacle.height * 0.25, obstacle.height * 0.15, 0, Math.PI * 2);
            mainCtx.arc(obstacleX + obstacle.width * 0.15, obstacleY + obstacle.height * 0.75, obstacle.height * 0.15, 0, Math.PI * 2);
            mainCtx.arc(obstacleX + obstacle.width * 0.85, obstacleY + obstacle.height * 0.25, obstacle.height * 0.15, 0, Math.PI * 2);
            mainCtx.arc(obstacleX + obstacle.width * 0.85, obstacleY + obstacle.height * 0.75, obstacle.height * 0.15, 0, Math.PI * 2);
            mainCtx.fill();

        } else if (obstacle.type === 'truck') {
            mainCtx.fillStyle = 'rgba(0,0,0,0.5)'; // Darker color for truck details
            // Cab
            mainCtx.fillRect(obstacleX, obstacleY, obstacle.width * 0.3, obstacle.height);
            // Trailer outline
            mainCtx.strokeStyle = 'rgba(0,0,0,0.5)';
            mainCtx.lineWidth = 2;
            mainCtx.strokeRect(obstacleX + obstacle.width * 0.3, obstacleY, obstacle.width * 0.7, obstacle.height);
            // Wheels
            mainCtx.fillStyle = '#333';
            mainCtx.beginPath();
            mainCtx.arc(obstacleX + obstacle.width * 0.15, obstacleY + obstacle.height * 0.85, obstacle.height * 0.1, 0, Math.PI * 2); // Front wheel
            mainCtx.arc(obstacleX + obstacle.width * 0.4, obstacleY + obstacle.height * 0.85, obstacle.height * 0.1, 0, Math.PI * 2); // Trailer wheel 1
            mainCtx.arc(obstacleX + obstacle.width * 0.65, obstacleY + obstacle.height * 0.85, obstacle.height * 0.1, 0, Math.PI * 2); // Trailer wheel 2
            mainCtx.arc(obstacleX + obstacle.width * 0.9, obstacleY + obstacle.height * 0.85, obstacle.height * 0.1, 0, Math.PI * 2); // Trailer wheel 3
            mainCtx.fill();

        } else if (obstacle.type === 'train') {
            mainCtx.fillStyle = 'rgba(0,0,0,0.5)'; // Darker color for train details
            // Windows
            mainCtx.fillRect(obstacleX + obstacle.width * 0.1, obstacleY + obstacle.height * 0.2, obstacle.width * 0.15, obstacle.height * 0.6);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.3, obstacleY + obstacle.height * 0.2, obstacle.width * 0.15, obstacle.height * 0.6);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.5, obstacleY + obstacle.height * 0.2, obstacle.width * 0.15, obstacle.height * 0.6);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.7, obstacleY + obstacle.height * 0.2, obstacle.width * 0.15, obstacle.height * 0.6);
            // Connectors (simplified)
            mainCtx.fillStyle = '#666';
            mainCtx.fillRect(obstacleX - 5, obstacleY + obstacle.height / 2 - 2, 10, 4); // Left connector
            mainCtx.fillRect(obstacleX + obstacle.width - 5, obstacleY + obstacle.height / 2 - 2, 10, 4); // Right connector
            // Wheels (simplified rectangles at the bottom)
            mainCtx.fillStyle = '#333';
            mainCtx.fillRect(obstacleX + obstacle.width * 0.05, obstacleY + obstacle.height * 0.8, obstacle.width * 0.2, obstacle.height * 0.15);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.3, obstacleY + obstacle.height * 0.8, obstacle.width * 0.2, obstacle.height * 0.15);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.55, obstacleY + obstacle.height * 0.8, obstacle.width * 0.2, obstacle.height * 0.15);
            mainCtx.fillRect(obstacleX + obstacle.width * 0.8, obstacleY + obstacle.height * 0.8, obstacle.width * 0.15, obstacle.height * 0.15);
        }
      });

      // Draw brushing value as text (will appear un-mirrored on screen)
      mainCtx.fillStyle = '#fff';
      mainCtx.font = '20px Arial';
      mainCtx.textAlign = 'right';
      mainCtx.textBaseline = 'top';
      mainCtx.fillText(`Brushing: ${brushingValue.toFixed(2)} (Smoothed: ${smoothedBrushingImpact.toFixed(2)})`, overlayWidth - 10, 10);


      // Game Over Text or Game Won Text
      if (gameOver) {
        let message = 'GAME OVER!';
        let subMessage = 'You hit an obstacle. Click "Start camera" to play again.';
        let textColor = 'rgba(255, 0, 0, 0.7)';
        if (gameWon) {
            message = 'YOU WON!';
            subMessage = 'Congratulations! Click "Start camera" to play again.';
            textColor = 'rgba(0, 255, 0, 0.7)';
        }
        mainCtx.fillStyle = textColor;
        mainCtx.font = 'bold 48px Arial';
        mainCtx.textAlign = 'center';
        mainCtx.textBaseline = 'middle';
        mainCtx.fillText(message, overlayWidth / 2, overlayHeight / 2);
        mainCtx.font = 'bold 24px Arial';
        mainCtx.fillText(subMessage, overlayWidth / 2, overlayHeight / 2 + 40);
      }

      mainCtx.restore();
    }


    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!detector || !ui.video.videoWidth) {
        if (gameOver && ui.video.srcObject) { // Clear canvas once on game over or game won
          mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
          mainCtx.save();
          mainCtx.scale(-1, 1);
          mainCtx.translate(-overlayWidth, 0);

          let message = 'GAME OVER!';
          let subMessage = 'You hit an obstacle. Click "Start camera" to play again.';
          let textColor = 'rgba(255, 0, 0, 0.7)';
          if (gameWon) {
              message = 'YOU WON!';
              subMessage = 'Congratulations! Click "Start camera" to play again.';
              textColor = 'rgba(0, 255, 0, 0.7)';
          }

          mainCtx.fillStyle = textColor;
          mainCtx.font = 'bold 48px Arial';
          mainCtx.textAlign = 'center';
          mainCtx.textBaseline = 'middle';
          mainCtx.fillText(message, overlayWidth / 2, overlayHeight / 2);
          mainCtx.font = 'bold 24px Arial';
          mainCtx.fillText(subMessage, overlayWidth / 2, overlayHeight / 2 + 40);
          mainCtx.restore();
        }
        return; // Don't proceed if game is over or camera/detector not ready
      }
      if (gameOver) return; // Prevent game logic from running if already over

      const now = performance.now();
      if (ui.video.currentTime !== lastTime) {
        lastTime = ui.video.currentTime;

        mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
        mainCtx.drawImage(ui.video, 0, 0, overlayWidth, overlayHeight);

        const result = detector.detectForVideo(ui.video, now);
        let logLines = [];
        brushingValue *= BRUSHING_DECAY; // Apply decay to current brushing value

        let depthScale = 1.0; // Initialize depth scale

        if (result?.landmarks?.length) {
          ui.handsCount.textContent = String(result.landmarks.length);
          result.landmarks.forEach((lm, i) => {
            drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
            drawer.drawLandmarks(lm, { lineWidth: 1, radius: 3 });

            const rotation = estimateHandRotation(lm);
            const currentLaneCommand = getLaneFromPitch(rotation.pitch); // This now updates currentLaneState internally

            logLines.push(`Hand ${i+1}: Yaw: ${rotation.yaw}¬∞ Pitch: ${rotation.pitch}¬∞ Roll: ${rotation.roll}¬∞ -> Lane: ${currentLaneCommand}`);

            switch (currentLaneCommand) {
                case "up":
                    targetY = LANE_HEIGHT / 2;
                    break;
                case "down":
                    targetY = LANE_HEIGHT * 2.5;
                    break;
                case "front":
                default:
                    targetY = LANE_HEIGHT * 1.5;
                    break;
            }
            lastValidTargetY = targetY; // Update lastValidTargetY when a hand is detected

            if (lm.length > 0) {
              const currentX = lm[0].x * overlayWidth;
              const currentZ = lm[0].z; // Get the Z-coordinate of the wrist landmark

              // Calculate depth scaling factor
              // If currentZ is more negative (further away), depthScale will be > 1
              // If currentZ is less negative (closer), depthScale will be < 1
              // The `DEPTH_SCALING_FACTOR` determines how sensitive this scaling is.
              depthScale = Math.pow(REFERENCE_DEPTH_Z / currentZ, DEPTH_SCALING_FACTOR);
              // Ensure depthScale doesn't become too extreme or negative
              depthScale = Math.max(0.5, Math.min(depthScale, 3.0)); // Clamp between reasonable values

              handXPositions.push(currentX);
              if (handXPositions.length > HISTORY_SIZE) {
                handXPositions.shift();
              }

              if (handXPositions.length === HISTORY_SIZE) {
                let minX = handXPositions[0];
                let maxX = handXPositions[0];
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  if (handXPositions[j] < minX) minX = handXPositions[j];
                  if (handXPositions[j] > maxX) maxX = handXPositions[j];
                }
                const range = maxX - minX;

                let totalMovement = 0;
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  totalMovement += Math.abs(handXPositions[j] - handXPositions[j-1]);
                }

                // Apply depth scaling to the brushing calculation
                const currentBrushing = ((range * 0.01) + (totalMovement * 0.005)) * depthScale;
                if (currentBrushing > brushingValue) {
                    brushingValue = currentBrushing;
                }
              }
            }
          });
        } else {
          ui.handsCount.textContent = "0";
          logLines.push("No hand detected. Using last valid lane.");
          // Use the last known valid lane position
          targetY = lastValidTargetY; 
          // currentLaneState = "front"; // Optional: reset state if hand is not detected
          handXPositions = [];
        }

        // Apply smoothing to the brushing impact
        smoothedBrushingImpact = smoothedBrushingImpact * (1 - SMOOTHING_ALPHA) + brushingValue * SMOOTHING_ALPHA;
        
        ui.brushingValue.textContent = brushingValue.toFixed(2);

        // Game logic updates
        // Move obstacles and check for collisions
        let allObstaclesPassed = true;
        for (let i = level.obstacles.length - 1; i >= 0; i--) {
          const obstacle = level.obstacles[i];
          // Use the smoothedBrushingImpact for obstacle movement
          const obstacleMovement = obstacle.speed + (smoothedBrushingImpact * BRUSHING_IMPACT_FACTOR);
          obstacle.x -= obstacleMovement;

          if (checkCollision(objectX, objectY, PLAYER_SIZE, obstacle)) {
            gameOver = true;
            ui.log.textContent = "Game Over! You hit an obstacle.";
            break;
          }

          if (obstacle.x + obstacle.width/2 < objectX - PLAYER_SIZE / 2 && !obstacle.passed) {
            score++;
            ui.score.textContent = score;
            obstacle.passed = true;
          }
        }

        if (!gameOver && allObstaclesPassed && score === NUMBER_OF_OBSTACLES) {
            gameWon = true;
            gameOver = true; // Set game over to true so the win message displays
            ui.log.textContent = "Congratulations! You passed all obstacles!";
        }


        drawGameOverlay();

        frames++;
        if (now - lastFpsUpdate > 1000) {
          ui.fps.textContent = String(frames);
          frames = 0; lastFpsUpdate = now;
        }

        if (logLines.length) {
          ui.log.textContent = logLines.join("\n");
        }
      }
    }

    ui.startBtn.addEventListener('click', async () => {
      try { await startCamera(); }
      catch (err) {
        console.error(err);
        ui.log.textContent = String(err);
        ui.startBtn.disabled = false;
        setLive(false);
      }
    });
    ui.stopBtn.addEventListener('click', stopCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopCamera();
    });
  </script>
</body>
</html>