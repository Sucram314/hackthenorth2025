<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lane Control ‚Äî MediaPipe Hand Posture</title>
  <style>
    :root { --bg:#0b1020; --fg:#e8eef7; --accent:#5ad; --muted:#a8b3c7; }
    * { box-sizing: border-box; }
    body {
      margin: 0; font: 15px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--fg); background: radial-gradient(1200px 600px at 20% -10%, #1a2340 0%, #0b1020 50%, #060914 100%);
      min-height: 100dvh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: min(960px, 95vw);
      background: #101933cc; backdrop-filter: blur(6px);
      border: 1px solid #1e2a4d; border-radius: 18px; box-shadow: 0 15px 60px rgba(0,0,0,.35);
      padding: 18px 18px 12px; position: relative;
    }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .row { grid-template-columns: 3fr 2fr; } }
    h1 {
      margin: 2px 0 8px; font-weight: 700; letter-spacing: .2px;
      font-size: clamp(18px, 2.3vw, 26px);
      display:flex; align-items:center; gap:10px;
    }
    .badge { font-size: 12px; color: var(--muted); }
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button {
      appearance: none; border: 1px solid #355; background: #0e1a33; color: var(--fg);
      padding: 9px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    }
    button.primary { background: linear-gradient(180deg, #2b6cff, #1d54c9); border-color: #1d54c9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .pill {
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #2a3c69;
      border-radius: 999px; color: var(--muted); font-size: 12px;
    }
    .stage {
      position: relative; width: 100%; aspect-ratio: 16 / 9;
      background: #060a18; border:1px solid #1b294f; border-radius:14px; overflow:hidden;
      display: flex; justify-content: center; align-items: center;
    }
    /* Only the video will be truly hidden if we draw on overlay */
    video { transform: scaleX(-1); position:absolute; top:0; left:0; width:100%; height:100%; object-fit: cover; }
    /* The overlay canvas will now be our main display */
    #overlay {
      position: absolute; inset: 0; width:100%; height:100%;
      pointer-events: none; /* Allow interaction with elements behind if any */
      transform: scaleX(-1); /* Mirror the canvas content to match video selfie view */
    }
    /* We no longer need a separate gameCanvas */
    #gameCanvas {
      display: none; /* Hide the gameCanvas as we're drawing on overlay */
    }
    .watermark {
      position:absolute; top:8px; right:10px; font-size:12px; color:#cfe3ff; opacity:.8;
      background:#0b1430aa; padding:6px 8px; border-radius:10px; border:1px solid #1e2a4d;
      z-index: 10; /* Ensure watermark is on top */
      transform: scaleX(-1); /* Un-mirror watermark text */
    }
    .log {
      padding: 10px 12px; border:1px dashed #28407a; border-radius:12px; color: #c9d7ee; background:#0d162e;
      min-height: 64px; white-space:pre-wrap;
    }
    a { color:#9bd; }
    footer { margin-top: 8px; color: var(--muted); font-size: 12px; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; background:#7f8; box-shadow:0 0 0 3px #122; }
  </style>
</head>
<body>
  <div class="card">
    <h1>‚úã Lane Control <span class="badge">‚Äî MediaPipe Hand Posture</span></h1>
    <div class="toolbar">
      <button id="startBtn" class="primary">Start camera</button>
      <button id="stopBtn" disabled>Stop camera</button>
      <span class="pill"><span class="dot" id="dot"></span><span id="status">idle</span></span>
      <span class="pill" title="frames per second">FPS: <strong id="fps">0</strong></span>
      <span class="pill">Hands: <strong id="handsCount">0</strong></span>
      <span class="pill">Brushing: <strong id="brushingValue">0.00</strong></span>
      <span class="pill">Score: <strong id="score">0</strong></span>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="stage">
        <!-- The video element will now be the background source for the canvas -->
        <video id="video" playsinline muted></video>
        <!-- The overlay canvas will now draw everything: video, landmarks, and game -->
        <canvas id="overlay"></canvas>
        <!-- The dedicated gameCanvas is no longer needed -->
        <canvas id="gameCanvas" width="640" height="360" style="display:none;"></canvas>
        <div class="watermark">Hand landmarks + game overlay</div>
      </div>
      <div class="log" id="log">Click ‚ÄúStart camera‚Äù, allow permission, then hold your hand up üñêÔ∏è.
        Tilt your hand up for the top lane.
        Tilt your hand down for the bottom lane.
        Hold it flat for the middle lane.
        Brush your hand back and forth horizontally to make obstacles move faster!
      </div>
    </div>

    <footer>
      Tip: This runs fully in your browser. Use HTTPS or localhost for camera access. Model provided by Google‚Äôs MediaPipe Hand Landmarker.
    </footer>
  </div>

  <script type="module">
    import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      startBtn: document.getElementById('startBtn'),
      stopBtn: document.getElementById('stopBtn'),
      dot: document.getElementById('dot'),
      status: document.getElementById('status'),
      fps: document.getElementById('fps'),
      handsCount: document.getElementById('handsCount'),
      brushingValue: document.getElementById('brushingValue'),
      score: document.getElementById('score'),
      log: document.getElementById('log'),
      video: document.getElementById('video'),
      overlay: document.getElementById('overlay'),
    };

    let stream;
    let detector;
    let rafId = 0;
    let lastTime = 0, frames = 0, lastFpsUpdate = 0;

    const mainCtx = ui.overlay.getContext('2d');
    const drawer = new DrawingUtils(mainCtx);

    let overlayWidth = 0;
    let overlayHeight = 0;

    let LANE_HEIGHT;
    const PLAYER_SIZE = 40;
    let objectY;
    let targetY;
    let objectX;

    // Brushing detection variables
    const HISTORY_SIZE = 10;
    let handXPositions = [];
    let brushingValue = 0;
    const BRUSHING_DECAY = 0.9;
    const BRUSHING_IMPACT_FACTOR = 8; // How much brushing affects obstacle speed
    let smoothedBrushingImpact = 0; // New variable for smoothed impact
    const SMOOTHING_ALPHA = 0.1; // Smoothing factor (0 to 1, lower = more smooth)


    // Game state variables
    let score = 0;
    let gameOver = false;
    let currentLaneState = "front"; // To keep track of the current hand posture state

    // Level definition and state
    let level = {
      obstacles: [],
      nextObstacleTime: 0, // When the next obstacle should appear
      minObstacleInterval: 1000, // Minimum time between obstacles (ms)
      maxObstacleInterval: 4000, // Maximum time between obstacles (ms)
      baseObstacleSpeed: 2, // Base speed for obstacles
      obstacleSize: 100, // Default obstacle size
      lanes: [0, 1, 2] // Lane indices
    };

    function setStatus(text){ ui.status.textContent = text; }
    function setLive(on){
      ui.dot.style.background = on ? '#7f8' : '#f88';
      setStatus(on ? 'live' : 'idle');
    }

    async function initDetector(){
      setStatus('loading model‚Ä¶');
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      detector = await HandLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    async function startCamera(){
      if (!detector) await initDetector();
      ui.startBtn.disabled = true;
      ui.stopBtn.disabled = false;
      setLive(true);
      gameOver = false;
      score = 0;
      ui.score.textContent = score;

      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: { ideal: 960 }, height: { ideal: 540 } },
        audio: false
      });
      ui.video.srcObject = stream;
      await ui.video.play();

      overlayWidth = ui.video.videoWidth;
      overlayHeight = ui.video.videoHeight;
      ui.overlay.width = overlayWidth;
      ui.overlay.height = overlayHeight;

      LANE_HEIGHT = overlayHeight / 3;
      objectY = LANE_HEIGHT * 1.5;
      targetY = objectY;
      objectX = overlayWidth / 4;

      handXPositions = [];
      brushingValue = 0;
      smoothedBrushingImpact = 0; // Initialize smoothed value
      currentLaneState = "front"; // Reset state on camera start

      level.obstacles = [];
      level.nextObstacleTime = performance.now() + Math.random() * (level.maxObstacleInterval - level.minObstacleInterval) + level.minObstacleInterval;

      lastTime = -1; frames = 0; lastFpsUpdate = performance.now();
      loop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      mainCtx.clearRect(0,0,ui.overlay.width, ui.overlay.height);
      ui.video.srcObject = null;
      ui.startBtn.disabled = false;
      ui.stopBtn.disabled = true;
      setLive(false);
      ui.handsCount.textContent = "0";
      ui.fps.textContent = "0";
      ui.brushingValue.textContent = "0.00";
      gameOver = true;
    }

    function estimateHandRotation(landmarks) {
      const wrist = landmarks[0];
      const middleMcp = landmarks[9];
      const pinkyMcp = landmarks[17];

      const vecUpX = middleMcp.x - wrist.x;
      const vecUpY = middleMcp.y - wrist.y;
      const vecUpZ = middleMcp.z - wrist.z;

      const magUp = Math.sqrt(vecUpX*vecUpX + vecUpY*vecUpY + vecUpZ*vecUpZ);
      const normUpY = vecUpY / magUp;

      const pitch = Math.asin(normUpY) * (180 / Math.PI);

      const vecSideX = pinkyMcp.x - wrist.x;
      const vecSideY = pinkyMcp.y - wrist.y;
      const roll = Math.atan2(vecSideY, vecSideX) * (180 / Math.PI);

      const yaw = Math.atan2(vecUpX, -vecUpZ) * (180 / Math.PI);

      return {
        yaw: parseFloat(yaw.toFixed(2)),
        pitch: parseFloat(pitch.toFixed(2)),
        roll: parseFloat(roll.toFixed(2)),
      };
    }

    function getLaneFromPitch(pitch) {
        // Define base thresholds
        const BASE_UP_THRESHOLD = -60;
        const BASE_DOWN_THRESHOLD = 30;

        // Define hysteresis bias
        const HYSTERESIS_BIAS = 10; // degrees

        let upThreshold = BASE_UP_THRESHOLD;
        let downThreshold = BASE_DOWN_THRESHOLD;

        // Apply bias based on current state
        if (currentLaneState === "up") {
            // To go from "up" to "front", pitch must be greater than BASE_UP_THRESHOLD + BIAS
            upThreshold = BASE_UP_THRESHOLD + HYSTERESIS_BIAS/2;
        } else if (currentLaneState === "down") {
            // To go from "down" to "front", pitch must be less than BASE_DOWN_THRESHOLD - BIAS
            downThreshold = BASE_DOWN_THRESHOLD - HYSTERESIS_BIAS/2;
        } else if (currentLaneState === "front") {
            // To go from "front" to "up", pitch must be less than BASE_UP_THRESHOLD
            // To go from "front" to "down", pitch must be greater than BASE_DOWN_THRESHOLD
            upThreshold = BASE_UP_THRESHOLD - HYSTERESIS_BIAS/2;
            downThreshold = BASE_DOWN_THRESHOLD + HYSTERESIS_BIAS/2;
        }

        let newState;
        if (pitch < upThreshold) {
            newState = "down"; // Hand tilted upwards, means 'down' in selfie view
        } else if (pitch > downThreshold) {
            newState = "up"; // Hand tilted downwards, means 'up' in selfie view
        } else {
            newState = "front";
        }

        currentLaneState = newState; // Update the global state
        return newState;
    }

    function checkCollision(playerX, playerY, playerSize, obstacle) {
      const dx = playerX - obstacle.x;
      const dy = playerY - (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2);
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Using approximate bounding box for collision for simplicity with rect obstacles
      // Player (circle): centerX, centerY, radius
      // Obstacle (rect): x, y (top-left), width, height
      const playerRadius = playerSize / 2;
      const obstacleHalfSize = obstacle.size / 2;
      const obstacleCenterX = obstacle.x;
      const obstacleCenterY = (LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2);

      // Closest point on obstacle to player center
      let testX = playerX;
      let testY = playerY;

      if (playerX < obstacleCenterX - obstacleHalfSize) testX = obstacleCenterX - obstacleHalfSize;      // left edge
      else if (playerX > obstacleCenterX + obstacleHalfSize) testX = obstacleCenterX + obstacleHalfSize;   // right edge
      if (playerY < obstacleCenterY - obstacleHalfSize) testY = obstacleCenterY - obstacleHalfSize;      // top edge
      else if (playerY > obstacleCenterY + obstacleHalfSize) testY = obstacleCenterY + obstacleHalfSize;   // bottom edge

      const distX = playerX - testX;
      const distY = playerY - testY;
      const distanceSquared = (distX * distX) + (distY * distY);

      return distanceSquared <= (playerRadius * playerRadius);
    }


    function drawGameOverlay() {
      mainCtx.save();
      mainCtx.scale(-1, 1);
      mainCtx.translate(-overlayWidth, 0);

      // Draw lanes
      mainCtx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
      mainCtx.lineWidth = 2;
      mainCtx.beginPath();
      mainCtx.moveTo(0, LANE_HEIGHT);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT);
      mainCtx.moveTo(0, LANE_HEIGHT * 2);
      mainCtx.lineTo(overlayWidth, LANE_HEIGHT * 2);
      mainCtx.stroke();

      // Move player object smoothly
      if (Math.abs(targetY - objectY) > 1) {
          objectY += (targetY - objectY) * 0.1;
      } else {
          objectY = targetY;
      }

      // Draw the player object
      mainCtx.fillStyle = '#5ad';
      mainCtx.beginPath();
      mainCtx.arc(objectX, objectY, PLAYER_SIZE / 2, 0, Math.PI * 2);
      mainCtx.fill();

      // Draw obstacles
      level.obstacles.forEach(obstacle => {
        mainCtx.fillStyle = '#e84c3d'; // Obstacle color
        mainCtx.beginPath();
        const obstacleY = LANE_HEIGHT * obstacle.lane + LANE_HEIGHT / 2;
        mainCtx.rect(obstacle.x - obstacle.size / 2, obstacleY - obstacle.size / 2, obstacle.size, obstacle.size);
        mainCtx.fill();
      });

      // Draw brushing value as text (will appear un-mirrored on screen)
      mainCtx.fillStyle = '#fff';
      mainCtx.font = '20px Arial';
      mainCtx.textAlign = 'right';
      mainCtx.textBaseline = 'top';
      mainCtx.fillText(`Brushing: ${brushingValue.toFixed(2)} (Smoothed: ${smoothedBrushingImpact.toFixed(2)})`, overlayWidth - 10, 10);


      // Game Over Text
      if (gameOver) {
        mainCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
        mainCtx.font = 'bold 48px Arial';
        mainCtx.textAlign = 'center';
        mainCtx.textBaseline = 'middle';
        mainCtx.fillText('GAME OVER!', overlayWidth / 2, overlayHeight / 2);
        mainCtx.font = 'bold 24px Arial';
        mainCtx.fillText('Click "Start camera" to play again', overlayWidth / 2, overlayHeight / 2 + 40);
      }

      mainCtx.restore();
    }


    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!detector || !ui.video.videoWidth) {
        if (gameOver && ui.video.srcObject) { // Clear canvas once on game over
          mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
          mainCtx.save();
          mainCtx.scale(-1, 1);
          mainCtx.translate(-overlayWidth, 0);
          mainCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          mainCtx.font = 'bold 48px Arial';
          mainCtx.textAlign = 'center';
          mainCtx.textBaseline = 'middle';
          mainCtx.fillText('GAME OVER!', overlayWidth / 2, overlayHeight / 2);
          mainCtx.font = 'bold 24px Arial';
          mainCtx.fillText('Click "Start camera" to play again', overlayWidth / 2, overlayHeight / 2 + 40);
          mainCtx.restore();
        }
        return; // Don't proceed if game is over or camera/detector not ready
      }
      if (gameOver) return; // Prevent game logic from running if already over

      const now = performance.now();
      if (ui.video.currentTime !== lastTime) {
        lastTime = ui.video.currentTime;

        mainCtx.clearRect(0,0,overlayWidth, overlayHeight);
        mainCtx.drawImage(ui.video, 0, 0, overlayWidth, overlayHeight);

        const result = detector.detectForVideo(ui.video, now);
        let logLines = [];
        brushingValue *= BRUSHING_DECAY; // Apply decay to current brushing value

        if (result?.landmarks?.length) {
          ui.handsCount.textContent = String(result.landmarks.length);
          result.landmarks.forEach((lm, i) => {
            drawer.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS, { lineWidth: 3 });
            drawer.drawLandmarks(lm, { lineWidth: 1, radius: 3 });

            const rotation = estimateHandRotation(lm);
            const currentLaneCommand = getLaneFromPitch(rotation.pitch); // This now updates currentLaneState internally

            logLines.push(`Hand ${i+1}: Yaw: ${rotation.yaw}¬∞ Pitch: ${rotation.pitch}¬∞ Roll: ${rotation.roll}¬∞ -> Lane: ${currentLaneCommand}`);

            switch (currentLaneCommand) {
                case "up":
                    targetY = LANE_HEIGHT / 2;
                    break;
                case "down":
                    targetY = LANE_HEIGHT * 2.5;
                    break;
                case "front":
                default:
                    targetY = LANE_HEIGHT * 1.5;
                    break;
            }

            if (lm.length > 0) {
              const currentX = lm[0].x * overlayWidth;
              handXPositions.push(currentX);
              if (handXPositions.length > HISTORY_SIZE) {
                handXPositions.shift();
              }

              if (handXPositions.length === HISTORY_SIZE) {
                let minX = handXPositions[0];
                let maxX = handXPositions[0];
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  if (handXPositions[j] < minX) minX = handXPositions[j];
                  if (handXPositions[j] > maxX) maxX = handXPositions[j];
                }
                const range = maxX - minX;

                let totalMovement = 0;
                for (let j = 1; j < HISTORY_SIZE; j++) {
                  totalMovement += Math.abs(handXPositions[j] - handXPositions[j-1]);
                }

                const currentBrushing = (range * 0.01) + (totalMovement * 0.005);
                if (currentBrushing > brushingValue) {
                    brushingValue = currentBrushing;
                }
              }
            }
          });
        } else {
          ui.handsCount.textContent = "0";
          logLines.push("No hand detected. Defaulting to middle lane.");
          targetY = LANE_HEIGHT * 1.5;
          currentLaneState = "front"; // Reset state if hand is not detected
          handXPositions = [];
        }

        // Apply smoothing to the brushing impact
        smoothedBrushingImpact = smoothedBrushingImpact * (1 - SMOOTHING_ALPHA) + brushingValue * SMOOTHING_ALPHA;
        
        ui.brushingValue.textContent = brushingValue.toFixed(2);

        // Game logic updates
        // Generate new obstacles
        if (now >= level.nextObstacleTime) {
          const randomLane = level.lanes[Math.floor(Math.random() * level.lanes.length)];
          level.obstacles.push({
            lane: randomLane,
            x: overlayWidth + level.obstacleSize, // Start off-screen to the right
            speed: level.baseObstacleSpeed,
            size: level.obstacleSize,
            passed: false
          });
          level.nextObstacleTime = now + Math.random() * (level.maxObstacleInterval - level.minObstacleInterval) + level.minObstacleInterval;
        }

        // Move obstacles and check for collisions
        for (let i = level.obstacles.length - 1; i >= 0; i--) {
          const obstacle = level.obstacles[i];
          // Use the smoothedBrushingImpact for obstacle movement
          const obstacleMovement = obstacle.speed + (smoothedBrushingImpact * BRUSHING_IMPACT_FACTOR);
          obstacle.x -= obstacleMovement;

          if (checkCollision(objectX, objectY, PLAYER_SIZE, obstacle)) {
            gameOver = true;
            ui.log.textContent = "Game Over! You hit an obstacle.";
            break;
          }

          if (obstacle.x < objectX - PLAYER_SIZE / 2 && !obstacle.passed) {
            score++;
            ui.score.textContent = score;
            obstacle.passed = true;
          }

          if (obstacle.x < -obstacle.size) {
            level.obstacles.splice(i, 1);
          }
        }


        drawGameOverlay();

        frames++;
        if (now - lastFpsUpdate > 1000) {
          ui.fps.textContent = String(frames);
          frames = 0; lastFpsUpdate = now;
        }

        if (logLines.length) {
          ui.log.textContent = logLines.join("\n");
        }
      }
    }

    ui.startBtn.addEventListener('click', async () => {
      try { await startCamera(); }
      catch (err) {
        console.error(err);
        ui.log.textContent = String(err);
        ui.startBtn.disabled = false;
        setLive(false);
      }
    });
    ui.stopBtn.addEventListener('click', stopCamera);

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) stopCamera();
    });
  </script>
</body>
</html>